#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <stddef.h>
#define LISTLEN 5

#ifdef __CHERI_PURE_CAPABILITY__
#define PRINTF_PTR "#p"
#else
#define PRINTF_PTR "p"
#endif

typedef struct obj {
  char password[10];
  char privateInformation[20];
  char buffer[10]; //buffer that will be affected by user input
  char publicInformation[20];
  void (**pptr)(struct obj * someObject); // pointer on function pointers attributes
  // function pointer attributes:
  void (*f1ptr)(struct obj * someObject); // pointer attribute to f1
  void (*f2ptr)(struct obj * someObject); // pointer attribute to f2
  void (*f3ptr)(struct obj * someObject); // pointer attribute to f3
  void (*f4ptr)(struct obj * someObject); // pointer attribute to f4
  void (*secret)(struct obj * someObject); // pointer attribute to secret
} object;

void f1(struct obj * someObject){ // printing public informations
  printf("public info:%s\n", someObject->publicInformation);
}

void f2(struct obj * someObject){ // verifying rights to change password
   printf("enter password\n");
   scanf("%s",someObject->buffer);
   if(strncmp(someObject->buffer, someObject->password, strlen(someObject->password)-1)==0){
      someObject->secret(someObject);
   }
   else {
        printf("bad password\n");
   }
}

void f3(struct obj * someObject){ // print private information if good password 
   printf("enter password\n");
   scanf("%s",someObject->buffer);
   if(strncmp(someObject->buffer, someObject->password, strlen(someObject->password)-1)==0){
      printf("private info:%s\n", someObject->privateInformation);
   }
   else {
        printf("bad password\n");
   }
}

void cleanInput(){
      int c;
      while( (c = fgetc(stdin)) != EOF && c != '\n');
}

void f4(struct obj * someObject){ // changing private and public informations, if good password
   char buffer[10];
   printf("enter password\n");
   scanf("%s",buffer); 
   if(strncmp(buffer, someObject->password, strlen(someObject->password)-1)==0){
      printf("changing private Information\n");
      cleanInput();
      scanf("%[ a-zA-Z]", someObject->privateInformation);
      cleanInput();
      printf("changing public Information\n");
      scanf("%[ a-zA-Z]", someObject->publicInformation);
   }
   else {
        printf("bad password\n");
   }
}
void secret(struct obj * someObject){ // changing password function
   char buf[2];
   int answered = 0;
   while (answered == 0){
    printf("change password ? Y/n\n");
    scanf("%s",buf);
    if(buf[0] == 'Y'){
      printf("enter new password\n");
      scanf("%s", someObject->password);
      answered = 1;
    } else {
      answered = 1;
   }
   }
}


void linkFunctions(struct obj * someObject){ // linking function pointer attributes to real functions
   someObject->f1ptr = &f1;
   someObject->f2ptr = &f2;
   someObject->f3ptr = &f3;
   someObject->f4ptr = &f4;
   someObject->secret = &secret;
}

struct obj * duplicate(struct obj * someObject){ // duplicate a struct obj
   struct obj * otherObject = calloc(1,sizeof(struct obj));
   strcpy(otherObject->password, someObject->password);
   strcpy(otherObject->buffer, someObject->buffer);
   strcpy(otherObject->publicInformation, someObject->publicInformation);
   strcpy(otherObject->privateInformation, someObject->privateInformation);
   linkFunctions(otherObject);
   // using an offset will not trigger CHERI hardware protection error because an invalid pointer can still access the address of the memory pointed
   size_t offset = (size_t)((char *)someObject->pptr - (char *)&someObject->pptr);
   printf("offset:%li\n",offset);
   printf("first object ptr value:%p\n",someObject->pptr);
   assert ((void *)((char *)&someObject->pptr+offset) == (char *)someObject->pptr);
   // using an offset we can determine which function was selected
   otherObject->pptr = (void (**)(struct obj *))((char*)&otherObject->pptr+offset); 
   printf("second object ptr value: %p\n", otherObject->pptr);
   return otherObject;
}

void debug(struct obj * someObject){ 
// print pointers address, value and dereferenced value of each pointer attribute of a structure
  printf("object:%"PRINTF_PTR"\n", someObject);
  printf("pptr:%"PRINTF_PTR"\n", &someObject->pptr);
  if(someObject->pptr != NULL){
     printf("*pptr:%"PRINTF_PTR"\n", someObject->pptr);
     printf("**pptr:%"PRINTF_PTR"\n", *(someObject->pptr));
  }
  printf("f1ptr:%"PRINTF_PTR"\n", &someObject->f1ptr);
  printf("f2ptr:%"PRINTF_PTR"\n", &someObject->f2ptr);
  printf("f3ptr:%"PRINTF_PTR"\n", &someObject->f3ptr);
  printf("f4ptr:%"PRINTF_PTR"\n", &someObject->f4ptr);
  printf("secret ptr:%"PRINTF_PTR"\n", &someObject->secret);
  printf("*f1ptr:%"PRINTF_PTR"\n", someObject->f1ptr);
  printf("*f2ptr:%"PRINTF_PTR"\n", someObject->f2ptr);
  printf("*f3ptr:%"PRINTF_PTR"\n", someObject->f3ptr);
  printf("*f4ptr:%"PRINTF_PTR"\n", someObject->f4ptr);
  printf("*secret:%"PRINTF_PTR"\n", someObject->secret);
}


int getInteger(){
   char * p,s[100];
   long n;
   cleanInput();
   while(fgets(s,sizeof(s),stdin)){
     n = strtol(s,&p, 10);
     if (p == s || *p !='\n'){
       printf("please enter integer:\n");
       cleanInput();
     } else break;
   }
   return n;
}


int main(){
   struct obj ** objList = calloc(LISTLEN, sizeof(struct obj *));
   for(int i = 0; i < LISTLEN; i++){
     objList[i] = NULL;
   }
   char buffer[20];
   int current = 0;
   
   // command loop
   while(strncmp(buffer, "exit",4)!=0){
      printf("current cell:%i\n", current);
      printf("list size:%i\n", LISTLEN);
      printf("enter command among: move, create, free, debug, call, duplicate\n");
      scanf("%s", buffer);
      printf("your command:%s\n", buffer);
      if(strncmp(buffer,"move",4)==0){
         printf("enter index of array\n");
      	 current = getInteger();

      }
      if(strncmp(buffer,"create",6)==0){ // creating new object
      	 if(objList[current] == NULL){
      	   printf("creating an object...\n");
      	   objList[current] = malloc(sizeof(struct obj));
      	   printf("enter password\n");
      	   scanf("%s",objList[current]->password);
      	   linkFunctions(objList[current]);
      	   cleanInput();
      	 } else {
      	   printf("this zone is already occupied\n");
      	 }
      } else {
      	if(current >=0 && current < LISTLEN){
      	    if(strncmp(buffer,"free",4)==0){ // freeing current object
      	       printf("freeing current object...\n");
               if(objList[current] != NULL){
                 free(objList[current]);
                 objList[current] = NULL;
               } else {
                 printf("nothing here already\n");
               }
      	    }
      	if(objList[current] != NULL){
      	    if(strncmp(buffer,"debug",5)==0){
               debug(objList[current]); // printing current object informations
      	    }
      	    if(strncmp(buffer,"duplicate",9)==0){ // duplicating current object
               int i; 
               // finding free space
               for(i = 0; i < LISTLEN; i++){
                 if(objList[i] == NULL){
                   break;
                 }
               }
               if(objList[i] == NULL){
                  objList[i] = duplicate(objList[current]);
                  printf("duplicated object in %i cell\n",i);
               } else {
                printf("no space left\n");
               }
      	    }
      	    if(strncmp(buffer,"call",4)==0){
      	    // call one function among f1, f2, f3 and f4
      	    // calling secret function is not supposed to be possible
         	printf("select function among f1, f2, f3, f4\n");
         	scanf("%s",buffer);
         	if(strncmp(buffer,"f1",2)==0){
          	  objList[current]->pptr = &objList[current]->f1ptr;
         	}
         	if(strncmp(buffer,"f2",2)==0){
         	   objList[current]->pptr = &objList[current]->f2ptr;
         	}
         	if(strncmp(buffer,"f3",2)==0){
            	  objList[current]->pptr = &objList[current]->f3ptr;
         	}
         	if(strncmp(buffer,"f4",2)==0){
          	  objList[current]->pptr = &objList[current]->f4ptr;
         	}
         	(*objList[current]->pptr)(objList[current]);
         	cleanInput();
             }
         }
         }
     }
      
   }
}


